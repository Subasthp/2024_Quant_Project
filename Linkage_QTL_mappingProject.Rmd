---
title: "Linkage and QTL mapping"
author: "QTL"
date: '2022-06-14'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Linkage map construction

Load data and estimate pairwise recombination fractions

To start with the analysis, we load the data using the function read.cross(), and estimate the pairwise recombination fractions (and their respective LOD scores) using the function est.rf():

```{r, warning = FALSE}
library(qtl)
maize <- read.cross(format = "csv", file = "maize.csv", genotypes = c("0", "1", "2"), crosstype = "riself")
#Cross type ("crosstype")
#"bc" for backcross
#"f2" for intercross
#"riself" for 2-way RIL by selfing
#"risib" for 2-way RIL by sib-mating
#"dh" for doubled haploids (like a backcross, but with genotype codes AA/BB)
#"haploid" for haploids (like a backcross, but with genotype codes A/B)
#"ail" for 2-way advanced intercross lines
#"mwriself" for 2k-way RIL by selfing
#"mwrisib" for 2k-way RIL by sib-mating
#"preriself" for partially-inbred 2k-way RIL by selfing
#"prerisib" for partially-inbred 2k-way RIL by sib-mating
#"do" for diversity outbred
#"hs" for 8-way heterogeneous stock
#"riself4", "riself8", and "riself16" for 4-, 8-, and 16-way RIL by selfing
#"risib4" and "risib8" for 4- and 8-way RIL by sib-mating
```

#Data summary:

```{r, warning = FALSE}
summary(maize)
geno.image(maize)
```

#Chi-squared tests for segregation distortion:

```{r}
gt.maize <- geno.table(maize) 
head(gt.maize)
table(gt.maize$P.value < 0.05)
table(gt.maize$P.value < 0.05/totmar(maize))
```
 

In order to segregation pattern chi-square test were employed to see whether each marker follows the 1:1 expected ratio of a RIL population using non-corrected testing chi-square test. 
Accordingly, out of 1106 markers about 911 (82%) were fit to mendelian segregation pattern while 195 (18%) were not followed mendelian segregation pattern. 
Therefore, beonforean correction were performed. Accordingly all markers were found mendial segeration distortion.

#Two-point recombination fraction calculation: 

```{r}
maize <- est.rf(maize)
dim(maize$rf)
plotRF(maize, col.scheme = "redblue")
```

The heatmap indicated that both the r estimates (above diagonal) and LOD scores (below diagonal) shows more blue, 
colder colors for non-linked markers (i.e. r≈0.5 and low LOD), and more red, warmer colors for the linked markers (i.e. r<0.5 and high LOD).


Once we have the pairwise recombination fraction estimates, we can try to see which markers are in the same linkage group. In order to do so, we need to provide the maximum recombination fraction (max.rf argument) and minimum LOD score (min.lod argument). This values are provided to the function formLinkageGroups() and they are used to see whether two markers are linked or not while avoiding false positives. We will show where these values come from, but you can use them directly in your analysis.

For max.rf, we can use something around 0.38, which is the value maximum recombination fraction of 0.50 when converted via Kosambi map function:

$$
m_{ij} = \frac{1}{4} \log{\left(\frac{1 + 2r_{ij}}{1 - 2r_{ij}}\right)}
$$
A recombination fraction as big as 0.50 means that two markers are independently segregating (i.e. these two markers are not linked). See below:

```{r}
max.rf <- 0.38
kosambi <- function(r) (1/4)*log((1+(2*r))/(1-(2*r)))
kosambi(r = max.rf)
```

# Partition markers into linkage groups:

For min.lod, we can run Bonferroni correction on the number of tests that we have to perform in order to evaluate marker linkage. The number of tests is the number of marker pairs that we have in our data. 

```{r}
(M <- totmar(maize)) # number of markers
(num.pair <- choose(M, 2)) # number of marker pairs
(min.lrt <- qchisq(1-(0.05/num.pair), 1)) # min LRT to consider two markers linked
(min.lod <- 0.2172 * min.lrt) # conversion of LRT to LOD

```
Now, it is time to see how many linkage groups we have. First, we run the function formLinkageGroups() with reorgMarkers = FALSE just to see how the markers get distributed along the formed linkage groups:

```{r, warning = FALSE}
lg <- formLinkageGroups(maize, max.rf = 0.38, min.lod = 6.25, reorgMarkers = F)
table(lg[,2])
```

We note that there are 10 linkage groups (as expected for maize). 
Now, we can use reorgMarkers = TRUE and update our cross object named maize with each marker numbered according to the linkage group it belongs:

```{r, warning = FALSE}
maize <- formLinkageGroups(maize, max.rf = 0.38, min.lod = 6.25, reorgMarkers = TRUE)
summary(maize)
plotRF(maize, col.scheme = "redblue")
```

The heatmap shows grouped but not yet ordered markers within each linkage group.

#Marker ordering

We are going to use the MDS algorithm and it is faster and usually more accurate.

```{r}
library(mappoly)
getMDSorder <- function(cross, chr) {
    markers <- match(names(cross$geno[[chr]]$map), colnames(cross$rf))
    mat <- cross$rf[markers, markers]
    rec.mat <- lod.mat <- matrix(rep(NA, length(markers)^2), nrow = length(markers))
    colnames(rec.mat) <- colnames(lod.mat) <- rownames(rec.mat) <- rownames(lod.mat) <- colnames(mat)
    lod.mat[upper.tri(lod.mat)] <- mat[upper.tri(mat)]
    lod.mat[lower.tri(lod.mat)] <- t(lod.mat)[lower.tri(lod.mat)]  #; image(lod.mat)
    rec.mat[lower.tri(rec.mat)] <- mat[lower.tri(mat)]
    rec.mat[upper.tri(rec.mat)] <- t(rec.mat)[upper.tri(rec.mat)]  #; image(rec.mat)
    input.mat <- NULL
    input.mat$rec.mat <- rec.mat
    input.mat$lod.mat <- lod.mat
    mds.map <- mappoly::mds_mappoly(input.mat)
    mds.ord <- match(as.character(mds.map$locimap$locus), colnames(mat))
    return(mds.ord)
}

```

#We’ll create a new object called maize.mds which is a copy of our original cross object maize, so that we can update the ordering within maize.mds only. In addition, we’ll create an empty object called
loglik.mds to store the log-likelihood of the orderings obtained using MDS:

```{r}
maize.mds <- maize
loglik.mds <- c()
#Linkage group 1
c <- 1
mds.ord <- getMDSorder(cross = maize.mds, chr = c)
maize.mds <- switch.order(cross = maize.mds, chr=c, order=mds.ord, maxit = 10000, tol=1e-5)
plotRF(maize.mds, chr=c, col.scheme = "redblue")

```


```{r, warning = FALSE}
# Loop through all linkage groups (assuming there are 10 linkage groups)
# Create a new object for maize and an empty vector for log-likelihoods
maize.mds <- maize
loglik.mds <- c()
for (c in 1:10) {
  # Get MDS order for the current linkage group
  mds.ord <- getMDSorder(cross = maize.mds, chr = c)
  
  # Switch order based on MDS ordering
  maize.mds <- switch.order(cross = maize.mds, chr = c, order = mds.ord, maxit = 10000, tol = 1e-5)
  
  # Plot RF for the current linkage group
  plotRF(maize.mds, chr = c, col.scheme = "redblue")
  
  # Pull map and log-likelihood for the current linkage group
  pull.map(maize.mds, chr = c)
  loglik.mds[c] <- attr(maize.mds$geno[[c]]$map, "loglik")
}

```


Final map:

```{r}
# Display summary table of the map with log-likelihoods
knitr::kable(cbind(summaryMap(maize.mds), log.likelihood = c(loglik.mds, sum(loglik.mds))))

# Plot the overall map
plotMap(maize.mds)
plotRF(maize.mds, col.scheme = "redblue")

# Save the workspace image
save.image("maize_mds.RData")
```

## QTL mapping

### Single marker analysis (SMA)


```{r}
# Step 1: Calculate genotype probabilities
# 'calc.genoprob' calculates the conditional genotype probabilities at each position.
# 'step = 1' defines the step size for the calculation (i.e., every 1 cM).
maize.mds <- calc.genoprob(cross = maize.mds, step = 1)
# Perform single marker analysis (SMA) using the method "mr" (marker regression).
maize.mr <- scanone(maize.mds, pheno.col = "PlantHeight", method = "mr")
# Summarize the significant markers from the scanone results.
# Displays a table with chromosome, position, and LOD score (logarithm of the odds).
summary(maize.mr)

# Run permutation tests to establish LOD thresholds.
# The function performs 'n.perm = 1000' permutations to generate a null distribution.
maize.perm.mr <- scanone(maize.mds, pheno.col = "PlantHeight", method = "mr", n.perm = 1000)

# Plot the results of the single marker analysis.
# The LOD score for each marker is plotted along the genome.
plot(maize.mr, type = "p", main = "Single marker analysis (SMA)")
# Add a significance threshold line to the plot based on permutation tests.
add.threshold(maize.mr, perms = maize.perm.mr, alpha = 0.05, lty = 2, col = "black")
```

### Interval mapping (IM)
```{r}
# Perform interval mapping (IM) using the Haley-Knott regression method (method = "hk").
maize.im <- scanone(cross = maize.mds, pheno.col = "PlantHeight", method = "hk")
# Summarize the results of the interval mapping.
summary(maize.im)

```

```{r, warning=FALSE}
# Perform permutation tests to calculate a significance threshold for QTL detection.
# n.perm = 1000 indicates that 1000 permutations are performed to assess the statistical significance of QTL.
# verbose = FALSE suppresses detailed output during the permutation process.
maize.perm.im <- scanone(cross = maize.mds, pheno.col = "PlantHeight", method = "hk", n.perm = 1000, verbose = FALSE)
# Plot the interval mapping results, with the LOD scores plotted against chromosomal positions.
plot(maize.im, col = "red", main = "Interval Mapping (IM)")

# Add a significance threshold line to the plot based on the permutation results.
add.threshold(maize.im, perms = maize.perm.im, alpha = 0.05, col = "red")

```

```{r}
# Plot the Single Marker Analysis (SMA) and Interval Mapping (IM) results
# 'type = c("p", "l")' specifies points for SMA and lines for IM
# 'col = c("black", "red")' sets the color for SMA as black and IM as red
plot(maize.mr, maize.im, type = c("p", "l"), col = c("black", "red"), main = "SMA versus IM")
# Add significance threshold to the SMA plot
add.threshold(maize.mr, perms = maize.perm.mr, alpha = 0.05, lty = 2, col = "black")
# Add significance threshold to the IM plot
add.threshold(maize.im, perms = maize.perm.im, alpha = 0.05, col = "red")
# Add a legend to the plot
legend("topright", legend = c("SMA", "IM"), lty = c(2, 1), col = c("black", "red"))

```


```{r}
maize.im.sig <- summary(maize.im, perms = maize.perm.im, alpha = 0.05)
maize.im.sig
```
### Composite interval mapping (CIM)

```{r,warning=FALSE}
# CIM with a 10 cM window
maize.cim10 <- cim(
  cross = maize.mds,               # The maize cross data
  pheno.col = "PlantHeight",        # Phenotype column for Plant Height
  method = "hk",                    # Using Haley-Knott regression
  n.marcovar = 2 * sqrt(nind(maize.mds)), # Number of marker covariates
  window = 10                       # Window size set to 10 cM
)

# CIM with a 15 cM window
maize.cim15 <- cim(
  cross = maize.mds,
  pheno.col = "PlantHeight",
  method = "hk",
  n.marcovar = 2 * sqrt(nind(maize.mds)),
  window = 15                       # Window size set to 15 cM
)

# CIM with a 20 cM window
maize.cim20 <- cim(
  cross = maize.mds,
  pheno.col = "PlantHeight",
  method = "hk",
  n.marcovar = 2 * sqrt(nind(maize.mds)),
  window = 20                       # Window size set to 20 cM
)

# CIM with an infinite window (considering the entire chromosome)
maize.cimInf <- cim(
  cross = maize.mds,
  pheno.col = "PlantHeight",
  method = "hk",
  n.marcovar = 2 * sqrt(nind(maize.mds)),
  window = Inf                      # Window size set to cover the entire chromosome
)

```

```{r}
summary(maize.cim10)
summary(maize.cim15)
summary(maize.cim20)
summary(maize.cimInf)
```

```{r,,warning=FALSE}
maize.perm.cim <- cim(cross = maize.mds, pheno.col = "PlantHeight", method = "hk",
    n.marcovar = 2 * sqrt(nind(maize.mds)), window = Inf, n.perm = 1000)
summary(maize.perm.cim, alpha = 0.05)
```


```{r}
summary(maize.cim10, perms = maize.perm.cim, alpha = 0.05)
summary(maize.cim15, perms = maize.perm.cim, alpha = 0.05)
summary(maize.cim20, perms = maize.perm.cim, alpha = 0.05)
summary(maize.cimInf, perms = maize.perm.cim, alpha = 0.05)
```

```{r}
plot(maize.cim10, maize.cim15, maize.cimInf, col = c("blue", "orange", "cyan"), main = "Composite interval mapping (CIM)")
add.threshold(maize.cim10, perms = maize.perm.cim, alpha = 0.05)
legend("topright", legend = c("ws = 10", "ws = 15", "ws = Inf"), lty = 1, col = c("blue",
    "orange", "cyan"))
```

```{r}
plot(maize.im, maize.cim10, maize.cimInf, col = c("red", "blue", "cyan"), main = "IM versus CIM")
add.threshold(maize.cim10, perms = maize.perm.cim, alpha = 0.05)
add.threshold(maize.im, perms = maize.perm.im, alpha = 0.05, col = "red")
legend("topright", legend = c("IM", "CIM (ws = 10)", "CIM (ws = Inf)"), lty = 1,
    col = c("red", "blue", "cyan"))
```

```{r}
plot(maize.im, maize.cim10, maize.cimInf, col = c("red", "blue", "cyan"), chr = c(1,
    2, 8), main = "IM versus CIM")
add.threshold(maize.im, perms = maize.perm.im, alpha = 0.05, col = "red")
add.threshold(maize.cim10, perms = maize.perm.cim, alpha = 0.05, col = "black")
add.cim.covar(maize.cimInf, chr = c(1, 2, 8), col = "green")
legend("topleft", legend = c("IM", "CIM (ws = 10)", "CIM (ws = Inf)"), lty = 1, col = c("red",
    "blue", "cyan"))
```

```{r}
maize.cim.sig <- summary(maize.cim10, perms = maize.perm.cim, alpha = 0.05)
maize.cim.sig
```

```{r}
peak.markers <- which(maize.cim10$lod[maize.cim10$chr == 1] > 7.39)
maize.cim10$lod[peak.markers]
```


```{r}
maize.cim10$pos[peak.markers]
```

### Multiple interval mapping (MIM)
Add main effects manually
R/qtl has several functions to deal with multiple-QTL models. 
#makeqtl and fitqtl
We will use the results from previous QTL run, namely composite interval mapping (CIM) 

First, we can take a look at the object (previously named maize.cim10) from the CIM with window = 10 run:

```{r}
summary(maize.cim10, perms = maize.perm.cim, alpha = 0.05)
```

```{r}
plot(maize.cim10)
add.threshold(maize.cim10, perms = maize.perm.cim, alpha = 0.05)
```

We noticed that three peaks had LOD score greater than our CIM threshold of 7.39. 

```{r}
max(maize.cim10[maize.cim10$chr == 1 & maize.cim10$pos > 140, ])
```

```{r}
chr <- c(1,  6, 7)
pos <- c(150,  70.00, 59)
```
In order to build a multiple-QTL model, we need to use the function calc.genoprob(), then makeqtl():
```{r}
maize.mds <- calc.genoprob(cross = maize.mds, step = 1)
maize.mds <- sim.geno(cross = maize.mds, step = 1, n.draws = 128, error.prob = 0.001)
maize.qtl <- makeqtl(cross = maize.mds, chr = chr, pos = pos)
maize.qtl
```

```{r}
plot(maize.qtl)
```
Then, we fit such a model using the fitqtl() function:
```{r}
maize.fit <- fitqtl(cross = maize.mds, pheno.col = "PlantHeight", qtl = maize.qtl,
    formula = y ~ Q1 + Q2 + Q3 , get.ests = TRUE)
summary(maize.fit)
```
Note that the Drop one QTL at a time ANOVA table shows that all five QTL are highly significant, so we keep them in the model.

# refineqtl and plotLodProfile
Every time we fit a new multiple-QTL model, it is recommended that we refine the QTL peak positions because there can be changes when testing each QTL conditional to the other QTL in the model. We perform this task using the function refineqtl() and plot the results using plotLodProfile():

```{r}
maize.ref <- refineqtl(cross = maize.mds, pheno.col = "PlantHeight", qtl = maize.qtl,
    formula = y ~ Q1 + Q2 + Q3 )
```

```{r}
plotLodProfile(maize.ref)
```
Then, another round of fitqtl() will provide updated tests for the new positions:
```{r}
maize.fit2 <- fitqtl(cross = maize.mds, pheno.col = "PlantHeight", qtl = maize.ref,
    formula = y ~ Q1 + Q2 + Q3 , get.ests = TRUE)
summary(maize.fit2)
```

#scantwo
In order to add main or epistatic effects, we need to find out what the “stop rule” is. In R/qtl, such a rule is given by penalized LOD score for a model with more than one QTL (function scantwo) provided by permutations (n.perm = 1000). This function takes a lot of time to run:

```{r}
permo.2dim <- scantwo(maize.mds, pheno.col = "PlantHeight", method = "hk", n.perm = 1000)
save(permo.2dim, file = "permo_2dim.RData")
```

Now, we can see a summary of the object permo.2dim and compute the penalties that will be used for automatic multiple-QTL model search:

```{r}
load("permo_2dim.RData")
summary(permo.2dim, alpha = 0.05)
```

```{r}
penalties <- calc.penalties(permo.2dim)
penalties
```

Thresholds derived from scantwo permutations (that is, for a two-dimensional, two-QTL genome scan) are used to calculate penalties on main effects and interactions. Look at help(calc.penalties) to learn more about the penalties. You can also find a detailed explanation on this criterion by Manichaikul et al. (2009).

#addqtl
What about the suggestive QTL on chromosome 5? If we want to verify if there are more QTL to be added to the model, we can use the function addqtl():
```{r}
maize.add <- addqtl(maize.mds, pheno.col = "PlantHeight", qtl = maize.ref, formula = y ~
    Q1 + Q2 + Q3 + Q4)
max(maize.add)
```
A LOD > 3 seems great enough to include this position on chromosome 5 as a QTL since the threshold for adding one main effect av1 = 2.91 (“light” LOD for main effects). So, let us add it to the model
```{r}
chr <- c(1, 5, 6, 7)
pos <- c(150, 52.4, 70.00, 59)
maize.qtl2 <- makeqtl(cross = maize.mds, chr = chr, pos = pos)
maize.qtl2
plot(maize.qtl2)
```

Remember that when a QTL happen to be added, one might need to refine positions again using refineqtl() function:
```{r}
maize.ref2 <- refineqtl(cross = maize.mds, pheno.col = "PlantHeight", qtl = maize.qtl2,
    formula = y ~ Q1 + Q2 + Q3 + Q4 )
plotLodProfile(maize.ref2)
```

Then, a new run of addqtl can be carried out:
```{r}
maize.add2 <- addqtl(maize.mds, pheno.col = "PlantHeight", qtl = maize.ref2, formula = y ~
    Q1 + Q2 + Q3 + Q4 + Q5)

```




